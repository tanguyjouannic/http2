use crate::error::Http2Error;
use crate::header::huffman::Direction::{Left, Right};

pub enum Node {
    Branch(Option<Box<Node>>, Option<Box<Node>>),
    Leaf(char),
}

impl Node {
    pub fn update(&mut self, code: &mut Code) -> Result<(), Http2Error> {
        // Exit condition.
        if code.directions.len() == 0 {
            match self {
                Node::Branch(_, _) => {
                    *self = Node::Leaf(code.symbol);
                    return Ok(());
                }
                Node::Leaf(_) => {
                    return Err(Http2Error::HuffmanDecodingError(
                        "Huffman Tree building error".to_string(),
                    ))
                }
            }
        }

        let direction = code.directions.remove(0);

        match direction {
            Left => {
                let node = match self {
                    Node::Branch(left, _) => left.get_or_insert(Box::new(Node::Branch(None, None))),
                    Node::Leaf(_) => {
                        return Err(Http2Error::HuffmanDecodingError(
                            "Huffman Tree building error".to_string(),
                        ))
                    } // Unexpected leaf
                };
                return node.update(code);
            }
            Right => {
                let node = match self {
                    Node::Branch(_, right) => {
                        right.get_or_insert(Box::new(Node::Branch(None, None)))
                    }
                    Node::Leaf(s) => {
                        println!("symbol: {}", s);
                        return Err(Http2Error::HuffmanDecodingError(
                            "Huffman Tree building error".to_string(),
                        ));
                    } // Unexpected leaf
                };
                return node.update(code);
            }
        }
    }

    pub fn find(&self, directions: &mut Vec<Direction>) -> Option<char> {
        if directions.len() == 0 {
            match self {
                Node::Branch(_, _) => return None,
                Node::Leaf(c) => {
                    return Some(*c);
                }
            }
        }

        match self {
            Node::Branch(left, right) => {
                let direction = directions.remove(0);

                match direction {
                    Left => match left {
                        Some(left_node) => left_node.find(directions),
                        None => None,
                    },
                    Right => match right {
                        Some(right_node) => right_node.find(directions),
                        None => None,
                    },
                }
            }
            Node::Leaf(c) => Some(*c),
        }
    }
}

#[derive(Debug)]
pub enum Direction {
    Left,
    Right,
}

impl Direction {
    pub fn from_byte(byte: u8) -> Vec<Direction> {
        let mut directions: Vec<Direction> = Vec::with_capacity(8);

        for i in 0..8 {
            let bit = (byte >> (7 - i)) & 1;

            match bit {
                0 => directions.push(Left),
                _ => directions.push(Right),
            }
        }

        directions
    }

    pub fn from_bytes(bytes: &Vec<u8>) -> Vec<Direction> {
        let mut directions: Vec<Direction> = Vec::with_capacity(bytes.len() * 8);

        for byte in bytes {
            let mut byte_directions = Direction::from_byte(byte.clone());
            directions.append(&mut byte_directions);
        }

        directions
    }
}

pub struct Code {
    directions: Vec<Direction>,
    symbol: char,
}

impl Code {
    pub fn from(code: &str, symbol: u8) -> Result<Code, Http2Error> {
        let mut directions: Vec<Direction> = Vec::with_capacity(32);

        for c in code.chars() {
            match c {
                '0' => directions.push(Left),
                '1' => directions.push(Right),
                _ => (),
            }
        }

        if directions.len() == 0 {
            return Err(Http2Error::HuffmanDecodingError("Empty code".to_string()));
        }

        Ok(Code {
            directions,
            symbol: symbol as char,
        })
    }
}

pub struct Tree {
    root: Node,
}

impl Tree {
    pub fn new() -> Result<Self, Http2Error> {
        let mut root = Node::Branch(None, None);
        let mut codes: Vec<Code> = Vec::with_capacity(257);

        for &(code, symbol) in HPACK_HUFFMAN_CODE.iter() {
            codes.push(Code::from(code, symbol)?);
        }

        for code in &mut codes {
            root.update(code)?;
        }

        Ok(Tree { root })
    }

    pub fn decode(&self, bytes: &mut Vec<u8>) -> Result<String, Http2Error> {
        let mut decoded: Vec<char> = Vec::new();
        let mut directions = Direction::from_bytes(bytes);
        println!("directions: {:?}", directions);

        while !directions.is_empty() {
            match self.root.find(&mut directions) {
                Some(symbol) => decoded.push(symbol),
                None => (),
            }
        }

        Ok(decoded.into_iter().collect())
    }
}

/// HPACK Huffman code table.
pub const HPACK_HUFFMAN_CODE: [(&str, u8); 256] = [
    ("1111111111000", 0),
    ("11111111111111111011000", 1),
    ("1111111111111111111111100010", 2),
    ("1111111111111111111111100011", 3),
    ("1111111111111111111111100100", 4),
    ("1111111111111111111111100101", 5),
    ("1111111111111111111111100110", 6),
    ("1111111111111111111111100111", 7),
    ("1111111111111111111111101000", 8),
    ("111111111111111111101010", 9),
    ("111111111111111111111111111100", 10),
    ("1111111111111111111111101001", 11),
    ("1111111111111111111111101010", 12),
    ("111111111111111111111111111101", 13),
    ("1111111111111111111111101011", 14),
    ("1111111111111111111111101100", 15),
    ("1111111111111111111111101101", 16),
    ("1111111111111111111111101110", 17),
    ("1111111111111111111111101111", 18),
    ("1111111111111111111111110000", 19),
    ("1111111111111111111111110001", 20),
    ("1111111111111111111111110010", 21),
    ("111111111111111111111111111110", 22),
    ("1111111111111111111111110011", 23),
    ("1111111111111111111111110100", 24),
    ("1111111111111111111111110101", 25),
    ("1111111111111111111111110110", 26),
    ("1111111111111111111111110111", 27),
    ("1111111111111111111111111000", 28),
    ("1111111111111111111111111001", 29),
    ("1111111111111111111111111010", 30),
    ("1111111111111111111111111011", 31),
    ("010100", 32),
    ("1111111000", 33),
    ("1111111001", 34),
    ("111111111010", 35),
    ("1111111111001", 36),
    ("010101", 37),
    ("11111000", 38),
    ("11111111010", 39),
    ("1111111010", 40),
    ("1111111011", 41),
    ("11111001", 42),
    ("11111111011", 43),
    ("11111010", 44),
    ("010110", 45),
    ("010111", 46),
    ("011000", 47),
    ("00000", 48),
    ("00001", 49),
    ("00010", 50),
    ("011001", 51),
    ("011010", 52),
    ("011011", 53),
    ("011100", 54),
    ("011101", 55),
    ("011110", 56),
    ("011111", 57),
    ("1011100", 58),
    ("11111011", 59),
    ("111111111111100", 60),
    ("100000", 61),
    ("111111111011", 62),
    ("1111111100", 63),
    ("1111111111010", 64),
    ("100001", 65),
    ("1011101", 66),
    ("1011110", 67),
    ("1011111", 68),
    ("1100000", 69),
    ("1100001", 70),
    ("1100010", 71),
    ("1100011", 72),
    ("1100100", 73),
    ("1100101", 74),
    ("1100110", 75),
    ("1100111", 76),
    ("1101000", 77),
    ("1101001", 78),
    ("1101010", 79),
    ("1101011", 80),
    ("1101100", 81),
    ("1101101", 82),
    ("1101110", 83),
    ("1101111", 84),
    ("1110000", 85),
    ("1110001", 86),
    ("1110010", 87),
    ("11111100", 88),
    ("1110011", 89),
    ("11111101", 90),
    ("1111111111011", 91),
    ("1111111111111110000", 92),
    ("1111111111100", 93),
    ("11111111111100", 94),
    ("100010", 95),
    ("111111111111101", 96),
    ("00011", 97),
    ("100011", 98),
    ("00100", 99),
    ("100100", 100),
    ("00101", 101),
    ("100101", 102),
    ("100110", 103),
    ("100111", 104),
    ("00110", 105),
    ("1110100", 106),
    ("1110101", 107),
    ("101000", 108),
    ("101001", 109),
    ("101010", 110),
    ("00111", 111),
    ("101011", 112),
    ("1110110", 113),
    ("101100", 114),
    ("01000", 115),
    ("01001", 116),
    ("101101", 117),
    ("1110111", 118),
    ("1111000", 119),
    ("1111001", 120),
    ("1111010", 121),
    ("1111011", 122),
    ("111111111111110", 123),
    ("11111111100", 124),
    ("11111111111101", 125),
    ("1111111111101", 126),
    ("1111111111111111111111111100", 127),
    ("11111111111111100110", 128),
    ("1111111111111111010010", 129),
    ("11111111111111100111", 130),
    ("11111111111111101000", 131),
    ("1111111111111111010011", 132),
    ("1111111111111111010100", 133),
    ("1111111111111111010101", 134),
    ("11111111111111111011001", 135),
    ("1111111111111111010110", 136),
    ("11111111111111111011010", 137),
    ("11111111111111111011011", 138),
    ("11111111111111111011100", 139),
    ("11111111111111111011101", 140),
    ("11111111111111111011110", 141),
    ("111111111111111111101011", 142),
    ("11111111111111111011111", 143),
    ("111111111111111111101100", 144),
    ("111111111111111111101101", 145),
    ("1111111111111111010111", 146),
    ("11111111111111111100000", 147),
    ("111111111111111111101110", 148),
    ("11111111111111111100001", 149),
    ("11111111111111111100010", 150),
    ("11111111111111111100011", 151),
    ("11111111111111111100100", 152),
    ("111111111111111011100", 153),
    ("1111111111111111011000", 154),
    ("11111111111111111100101", 155),
    ("1111111111111111011001", 156),
    ("11111111111111111100110", 157),
    ("11111111111111111100111", 158),
    ("111111111111111111101111", 159),
    ("1111111111111111011010", 160),
    ("111111111111111011101", 161),
    ("11111111111111101001", 162),
    ("1111111111111111011011", 163),
    ("1111111111111111011100", 164),
    ("11111111111111111101000", 165),
    ("11111111111111111101001", 166),
    ("111111111111111011110", 167),
    ("11111111111111111101010", 168),
    ("1111111111111111011101", 169),
    ("1111111111111111011110", 170),
    ("111111111111111111110000", 171),
    ("111111111111111011111", 172),
    ("1111111111111111011111", 173),
    ("11111111111111111101011", 174),
    ("11111111111111111101100", 175),
    ("111111111111111100000", 176),
    ("111111111111111100001", 177),
    ("1111111111111111100000", 178),
    ("111111111111111100010", 179),
    ("11111111111111111101101", 180),
    ("1111111111111111100001", 181),
    ("11111111111111111101110", 182),
    ("11111111111111111101111", 183),
    ("11111111111111101010", 184),
    ("1111111111111111100010", 185),
    ("1111111111111111100011", 186),
    ("1111111111111111100100", 187),
    ("11111111111111111110000", 188),
    ("1111111111111111100101", 189),
    ("1111111111111111100110", 190),
    ("11111111111111111110001", 191),
    ("11111111111111111111100000", 192),
    ("11111111111111111111100001", 193),
    ("11111111111111101011", 194),
    ("1111111111111110001", 195),
    ("1111111111111111100111", 196),
    ("11111111111111111110010", 197),
    ("1111111111111111101000", 198),
    ("1111111111111111111101100", 199),
    ("11111111111111111111100010", 200),
    ("11111111111111111111100011", 201),
    ("11111111111111111111100100", 202),
    ("111111111111111111111011110", 203),
    ("111111111111111111111011111", 204),
    ("11111111111111111111100101", 205),
    ("111111111111111111110001", 206),
    ("1111111111111111111101101", 207),
    ("1111111111111110010", 208),
    ("111111111111111100011", 209),
    ("11111111111111111111100110", 210),
    ("111111111111111111111100000", 211),
    ("111111111111111111111100001", 212),
    ("11111111111111111111100111", 213),
    ("111111111111111111111100010", 214),
    ("111111111111111111110010", 215),
    ("111111111111111100100", 216),
    ("111111111111111100101", 217),
    ("11111111111111111111101000", 218),
    ("11111111111111111111101001", 219),
    ("1111111111111111111111111101", 220),
    ("111111111111111111111100011", 221),
    ("111111111111111111111100100", 222),
    ("111111111111111111111100101", 223),
    ("11111111111111101100", 224),
    ("111111111111111111110011", 225),
    ("11111111111111101101", 226),
    ("111111111111111100110", 227),
    ("1111111111111111101001", 228),
    ("111111111111111100111", 229),
    ("111111111111111101000", 230),
    ("11111111111111111110011", 231),
    ("1111111111111111101010", 232),
    ("1111111111111111101011", 233),
    ("1111111111111111111101110", 234),
    ("1111111111111111111101111", 235),
    ("111111111111111111110100", 236),
    ("111111111111111111110101", 237),
    ("11111111111111111111101010", 238),
    ("11111111111111111110100", 239),
    ("11111111111111111111101011", 240),
    ("111111111111111111111100110", 241),
    ("11111111111111111111101100", 242),
    ("11111111111111111111101101", 243),
    ("111111111111111111111100111", 244),
    ("111111111111111111111101000", 245),
    ("111111111111111111111101001", 246),
    ("111111111111111111111101010", 247),
    ("111111111111111111111101011", 248),
    ("1111111111111111111111111110", 249),
    ("111111111111111111111101100", 250),
    ("111111111111111111111101101", 251),
    ("111111111111111111111101110", 252),
    ("111111111111111111111101111", 253),
    ("111111111111111111111110000", 254),
    ("11111111111111111111101110", 255),
];
